<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GITRIS WebSocket Test Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .game-section {
            flex: 2;
            display: flex;
            gap: 20px;
        }
        .player-area {
            flex: 1;
            border: 2px solid #333;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
        }
        .controls {
            flex: 1;
            border: 2px solid #333;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
        }
        .tetris-board {
            display: grid;
            grid-template-columns: repeat(10, 25px);
            grid-template-rows: repeat(20, 25px);
            gap: 1px;
            background: #000;
            padding: 5px;
            margin: 10px auto;
            border: 3px solid #444;
            border-radius: 5px;
            max-width: fit-content;
        }
        .cell {
            width: 25px;
            height: 25px;
            background: #111;
            border: 1px solid #333;
        }
        
        /* ãƒ†ãƒˆãƒªãƒŸãƒã®è‰² */
        .cell.type-0 { background: #4ecdc4; } /* I - ã‚·ã‚¢ãƒ³ */
        .cell.type-1 { background: #feca57; } /* O - é»„ */
        .cell.type-2 { background: #9b59b6; } /* T - ç´« */
        .cell.type-3 { background: #2ecc71; } /* S - ç·‘ */
        .cell.type-4 { background: #e74c3c; } /* Z - èµ¤ */
        .cell.type-5 { background: #3498db; } /* J - é’ */
        .cell.type-6 { background: #f39c12; } /* L - ã‚ªãƒ¬ãƒ³ã‚¸ */
        
        .cell.current {
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            border: 2px solid #fff;
            animation: pulse 1s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.6); }
            100% { box-shadow: 0 0 12px rgba(255, 255, 255, 0.9); }
        }
        
        .status {
            margin: 10px 0;
            padding: 15px;
            background: #333;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .status h3 {
            margin: 0 0 10px 0;
            color: #007bff;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #444;
        }
        .status-label {
            font-weight: bold;
        }
        .status-value {
            color: #4ecdc4;
        }
        
        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        .info-box {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .info-box .label {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }
        .info-box .value {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .log {
            height: 200px;
            overflow-y: auto;
            background: #000;
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        button {
            margin: 5px;
            padding: 10px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        input {
            padding: 10px;
            margin: 5px;
            border: 1px solid #555;
            border-radius: 5px;
            background: #333;
            color: #fff;
            width: calc(100% - 20px);
        }
        input::placeholder {
            color: #999;
        }
        
        .control-section {
            margin: 20px 0;
            padding: 15px;
            background: #333;
            border-radius: 8px;
        }
        .control-section h3 {
            margin: 0 0 15px 0;
            color: #4ecdc4;
            border-bottom: 2px solid #4ecdc4;
            padding-bottom: 5px;
        }
        
        .game-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .game-controls button {
            padding: 15px;
            font-size: 14px;
        }
        
        .connection-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
        }
        .status-connected { background: #28a745; color: white; }
        .status-disconnected { background: #dc3545; color: white; }
        .status-connecting { background: #ffc107; color: black; }
        
        h1 {
            text-align: center;
            color: #4ecdc4;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 30px;
        }
        h2 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .player-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        .player1-title { color: #ff6b6b; }
        .player2-title { color: #4ecdc4; }
        
        .next-piece, .hold-piece {
            margin: 10px 0;
            text-align: center;
        }
        .next-piece h4, .hold-piece h4 {
            margin: 5px 0;
            color: #999;
            font-size: 12px;
        }
        .mini-board {
            display: grid;
            grid-template-columns: repeat(4, 15px);
            grid-template-rows: repeat(4, 15px);
            gap: 1px;
            background: #000;
            padding: 3px;
            margin: 5px auto;
            border: 1px solid #444;
            max-width: fit-content;
        }
        .mini-cell {
            width: 15px;
            height: 15px;
            background: #111;
        }
    </style>
</head>
<body>
    <h1>ğŸ® GITRIS - WebSocket Test Client ğŸ®</h1>
    
    <div class="container">
        <div class="game-section">
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã‚¨ãƒªã‚¢ -->
            <div class="player-area">
                <div class="player-title player1-title">ğŸ‘¤ Player 1</div>
                
                <div class="status">
                    <h3>ã‚²ãƒ¼ãƒ çŠ¶æ…‹</h3>
                    <div class="status-item">
                        <span class="status-label">æ¥ç¶š:</span>
                        <span class="connection-status status-disconnected" id="connectionStatus">æœªæ¥ç¶š</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">ã‚²ãƒ¼ãƒ :</span>
                        <span class="status-value" id="gameStatus">å¾…æ©Ÿä¸­</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Player 1:</span>
                        <span class="status-value" id="player1Status">æœªå‚åŠ </span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Player 2:</span>
                        <span class="status-value" id="player2Status">æœªå‚åŠ </span>
                    </div>
                </div>
                
                <div class="tetris-board" id="player1Board"></div>
                
                <div class="game-info">
                    <div class="info-box">
                        <div class="label">ã‚¹ã‚³ã‚¢</div>
                        <div class="value" id="player1Score">0</div>
                    </div>
                    <div class="info-box">
                        <div class="label">ãƒ¬ãƒ™ãƒ«</div>
                        <div class="value" id="player1Level">1</div>
                    </div>
                    <div class="info-box">
                        <div class="label">ãƒ©ã‚¤ãƒ³</div>
                        <div class="value" id="player1Lines">0</div>
                    </div>
                    <div class="info-box">
                        <div class="label">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
                        <div class="value" id="player1GameOver">-</div>
                    </div>
                </div>
                
                <div class="next-piece">
                    <h4>Next</h4>
                    <div class="mini-board" id="player1Next"></div>
                </div>
                
                <div class="hold-piece">
                    <h4>Hold</h4>
                    <div class="mini-board" id="player1Hold"></div>
                </div>
            </div>
            
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã‚¨ãƒªã‚¢ -->
            <div class="player-area">
                <div class="player-title player2-title">ğŸ‘¤ Player 2</div>
                
                <div class="tetris-board" id="player2Board"></div>
                
                <div class="game-info">
                    <div class="info-box">
                        <div class="label">ã‚¹ã‚³ã‚¢</div>
                        <div class="value" id="player2Score">0</div>
                    </div>
                    <div class="info-box">
                        <div class="label">ãƒ¬ãƒ™ãƒ«</div>
                        <div class="value" id="player2Level">1</div>
                    </div>
                    <div class="info-box">
                        <div class="label">ãƒ©ã‚¤ãƒ³</div>
                        <div class="value" id="player2Lines">0</div>
                    </div>
                    <div class="info-box">
                        <div class="label">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
                        <div class="value" id="player2GameOver">-</div>
                    </div>
                </div>
                
                <div class="next-piece">
                    <h4>Next</h4>
                    <div class="mini-board" id="player2Next"></div>
                </div>
                
                <div class="hold-piece">
                    <h4>Hold</h4>
                    <div class="mini-board" id="player2Hold"></div>
                </div>
            </div>
        </div>
        
        <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
        <div class="controls">
            <h2>ğŸ›ï¸ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h2>
            
            <div class="control-section">
                <h3>ğŸ”Œ æ¥ç¶šè¨­å®š</h3>
                <input type="text" id="serverUrl" value="ws://localhost:8080" placeholder="WebSocket URL">
                <input type="text" id="roomId" placeholder="ãƒ«ãƒ¼ãƒ ID">
                <input type="text" id="userId" placeholder="ãƒ¦ãƒ¼ã‚¶ãƒ¼ID">
                <input type="text" id="authToken" placeholder="èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ (Bearer ...)" style="width: calc(100% - 20px);">
                <button onclick="connectWebSocket()">ğŸ”— WebSocketæ¥ç¶š</button>
                <button onclick="disconnect()">âŒ åˆ‡æ–­</button>
            </div>
            
            <div class="control-section">
                <h3>ğŸ® ã‚²ãƒ¼ãƒ æ“ä½œ</h3>
                                 <div class="game-controls">
                     <button onclick="sendAction('move_left')">â¬…ï¸ å·¦ç§»å‹•</button>
                     <button onclick="sendAction('move_right')">â¡ï¸ å³ç§»å‹•</button>
                     <button onclick="sendAction('rotate')">ğŸ”„ å›è»¢</button>
                     <button onclick="sendAction('soft_drop')">â¬‡ï¸ ã‚½ãƒ•ãƒˆ</button>
                     <button onclick="sendAction('hard_drop')">âš¡ ãƒãƒ¼ãƒ‰</button>
                     <button onclick="sendAction('hold')">ğŸ“¦ ãƒ›ãƒ¼ãƒ«ãƒ‰</button>
                 </div>
                 <div style="margin-top: 10px; font-size: 12px; color: #999;">
                     ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰: â†â†’ç§»å‹• â†‘ãƒãƒ¼ãƒ‰ â†“ã‚½ãƒ•ãƒˆ / Space=å›è»¢ / C=ãƒ›ãƒ¼ãƒ«ãƒ‰
                 </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ  ãƒ«ãƒ¼ãƒ æ“ä½œ</h3>
                <button onclick="createRoom()">ğŸ—ï¸ ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
                <button onclick="joinRoom()">ğŸšª ãƒ«ãƒ¼ãƒ å‚åŠ </button>
            </div>
            
            <div class="control-section">
                <h3>ğŸ“‹ ãƒ­ã‚°</h3>
                <div class="log" id="log"></div>
                <button onclick="clearLog()">ğŸ—‘ï¸ ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let gameState = null;
        
        // ãƒ­ã‚°å‡ºåŠ›
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        // æ¥ç¶šçŠ¶æ…‹ã®æ›´æ–°
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.className = 'connection-status';
            
            switch(status) {
                case 'connected':
                    statusElement.textContent = 'æ¥ç¶šæ¸ˆã¿';
                    statusElement.classList.add('status-connected');
                    break;
                case 'connecting':
                    statusElement.textContent = 'æ¥ç¶šä¸­';
                    statusElement.classList.add('status-connecting');
                    break;
                case 'disconnected':
                default:
                    statusElement.textContent = 'æœªæ¥ç¶š';
                    statusElement.classList.add('status-disconnected');
                    break;
            }
        }
        
        // WebSocketæ¥ç¶š
        function connectWebSocket() {
            const roomId = document.getElementById('roomId').value;
            const authToken = document.getElementById('authToken').value;
            
            if (!roomId) {
                alert('ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!authToken) {
                alert('èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const wsUrl = `ws://localhost:8080/api/game/ws/${roomId}`;
            log(`WebSocketæ¥ç¶šã‚’è©¦è¡Œä¸­: ${wsUrl}`);
            updateConnectionStatus('connecting');
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(event) {
                log('WebSocketæ¥ç¶šãŒé–‹ã‹ã‚Œã¾ã—ãŸ');
                updateConnectionStatus('connected');
                
                // èªè¨¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
                const authMessage = {
                    type: 'auth',
                    token: authToken
                };
                socket.send(JSON.stringify(authMessage));
                log('èªè¨¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
            };
            
            socket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ã®ç¨®é¡ã‚’åˆ¤å®š
                    if (data.type) {
                        // type ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å ´åˆï¼ˆèªè¨¼å¿œç­”ãªã©ï¼‰
                        if (data.type === 'auth_success') {
                            log('èªè¨¼ãŒæˆåŠŸã—ã¾ã—ãŸ');
                        } else {
                            handleGameMessage(data);
                        }
                    } else if (data.id && (data.player1 || data.player2)) {
                        // GameSessionã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
                        updateGameState(data);
                    } else {
                        log(`æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼: ${JSON.stringify(data).substring(0, 100)}...`);
                    }
                } catch (error) {
                    log(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            };
            
            socket.onerror = function(event) {
                log(`WebSocketã‚¨ãƒ©ãƒ¼: ${event}`);
                updateConnectionStatus('disconnected');
            };
            
            socket.onclose = function(event) {
                log(`WebSocketæ¥ç¶šãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ: ${event.code} - ${event.reason}`);
                socket = null;
                updateConnectionStatus('disconnected');
            };
        }
        
        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
        }
        
        // ãƒœãƒ¼ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ã®ãŸã‚
        const boardCache = {};
        
        // ãƒ†ãƒˆãƒªã‚¹ãƒœãƒ¼ãƒ‰ã®æç”»ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ç‰ˆï¼‰
        function drawTetrisBoard(boardId, boardData, currentPiece = null) {
            const boardElement = document.getElementById(boardId);
            if (!boardElement) return;
            
            // ãƒœãƒ¼ãƒ‰ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿DOMã‚’ä½œæˆ
            if (!boardCache[boardId]) {
                boardElement.innerHTML = '';
                boardCache[boardId] = { cells: [], lastUpdate: null };
                
                // 20è¡Œ x 10åˆ—ã®ã‚»ãƒ«ã‚’ä½œæˆ
                for (let row = 0; row < 20; row++) {
                    boardCache[boardId].cells[row] = [];
                    for (let col = 0; col < 10; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        boardCache[boardId].cells[row][col] = cell;
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            const cells = boardCache[boardId].cells;
            
            // å…¨ã‚»ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŠ¹ç‡çš„ã«ï¼‰
            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    cells[row][col].className = 'cell';
                }
            }
            
            // ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’é©ç”¨
            if (boardData && Array.isArray(boardData)) {
                for (let row = 0; row < Math.min(20, boardData.length); row++) {
                    if (Array.isArray(boardData[row])) {
                        for (let col = 0; col < Math.min(10, boardData[row].length); col++) {
                            const cellValue = boardData[row][col];
                            if (cellValue && cellValue > 0) {
                                // BlockType (1-7) ã‚’ PieceType (0-6) ã«å¤‰æ›
                                cells[row][col].classList.add(`type-${cellValue - 1}`);
                            }
                        }
                    }
                }
            }
            
            // ç¾åœ¨ã®ãƒ”ãƒ¼ã‚¹ã‚’æç”»
            if (currentPiece && typeof currentPiece.x === 'number' && typeof currentPiece.y === 'number' && typeof currentPiece.type === 'number') {
                const pieceBlocks = getPieceBlocks(currentPiece.type, currentPiece.rotation || 0);
                
                for (const block of pieceBlocks) {
                    const boardRow = currentPiece.y + block[1];
                    const boardCol = currentPiece.x + block[0];
                    
                    if (boardRow >= 0 && boardRow < 20 && boardCol >= 0 && boardCol < 10) {
                        cells[boardRow][boardCol].classList.add('current');
                        // PieceType (0-6) ã‚’ãã®ã¾ã¾ä½¿ç”¨
                        cells[boardRow][boardCol].classList.add(`type-${currentPiece.type}`);
                    }
                }
            }
        }
        
        // ãƒ†ãƒˆãƒªãƒŸãƒã®å½¢çŠ¶ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        function getPieceBlocks(pieceType, rotation) {
            const pieceShapes = {
                0: [ // TypeI
                    [[0, 1], [1, 1], [2, 1], [3, 1]], // 0åº¦ (æ¨ª)
                    [[2, 0], [2, 1], [2, 2], [2, 3]], // 90åº¦ (ç¸¦)
                    [[0, 2], [1, 2], [2, 2], [3, 2]], // 180åº¦ (æ¨ª)
                    [[1, 0], [1, 1], [1, 2], [1, 3]], // 270åº¦ (ç¸¦)
                ],
                1: [ // TypeO
                    [[0, 0], [1, 0], [0, 1], [1, 1]], // å…¨ã¦ã®å›è»¢ã§åŒã˜
                ],
                2: [ // TypeT
                    [[1, 0], [0, 1], [1, 1], [2, 1]], // 0åº¦
                    [[1, 0], [1, 1], [2, 1], [1, 2]], // 90åº¦
                    [[0, 1], [1, 1], [2, 1], [1, 2]], // 180åº¦
                    [[0, 1], [1, 0], [1, 1], [1, 2]], // 270åº¦
                ],
                3: [ // TypeS
                    [[1, 0], [2, 0], [0, 1], [1, 1]], // 0åº¦
                    [[1, 0], [1, 1], [2, 1], [2, 2]], // 90åº¦
                    [[1, 1], [2, 1], [0, 2], [1, 2]], // 180åº¦
                    [[0, 0], [0, 1], [1, 1], [1, 2]], // 270åº¦
                ],
                4: [ // TypeZ
                    [[0, 0], [1, 0], [1, 1], [2, 1]], // 0åº¦
                    [[2, 0], [1, 1], [2, 1], [1, 2]], // 90åº¦
                    [[0, 1], [1, 1], [1, 2], [2, 2]], // 180åº¦
                    [[1, 0], [0, 1], [1, 1], [0, 2]], // 270åº¦
                ],
                5: [ // TypeJ
                    [[0, 0], [0, 1], [1, 1], [2, 1]], // 0åº¦
                    [[1, 0], [2, 0], [1, 1], [1, 2]], // 90åº¦
                    [[0, 1], [1, 1], [2, 1], [2, 2]], // 180åº¦
                    [[1, 0], [1, 1], [0, 2], [1, 2]], // 270åº¦
                ],
                6: [ // TypeL
                    [[2, 0], [0, 1], [1, 1], [2, 1]], // 0åº¦
                    [[1, 0], [1, 1], [1, 2], [2, 2]], // 90åº¦
                    [[0, 1], [1, 1], [2, 1], [0, 2]], // 180åº¦
                    [[0, 0], [1, 0], [1, 1], [1, 2]], // 270åº¦
                ],
            };
            
            const shapes = pieceShapes[pieceType];
            if (!shapes) {
                log(`Unknown piece type: ${pieceType}`);
                return [];
            }
            
            // OãƒŸãƒã¯å›è»¢ã—ãªã„
            if (pieceType === 1) {
                return shapes[0];
            }
            
            const rotIdx = Math.floor((rotation || 0) / 90) % 4;
            return shapes[rotIdx] || shapes[0];
        }
        
        // ãƒŸãƒ‹ãƒœãƒ¼ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const miniBoardCache = {};
        
        // ãƒŸãƒ‹ãƒœãƒ¼ãƒ‰ï¼ˆNext/Holdï¼‰ã®æç”»ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
        function drawMiniBoard(boardId, pieceData) {
            const boardElement = document.getElementById(boardId);
            if (!boardElement) return;
            
            // ãƒœãƒ¼ãƒ‰ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿DOMã‚’ä½œæˆ
            if (!miniBoardCache[boardId]) {
                boardElement.innerHTML = '';
                miniBoardCache[boardId] = { cells: [], lastPieceType: null };
                
                // 4x4ã®ã‚»ãƒ«ã‚’ä½œæˆ
                for (let row = 0; row < 4; row++) {
                    miniBoardCache[boardId].cells[row] = [];
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'mini-cell';
                        miniBoardCache[boardId].cells[row][col] = cell;
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            const cells = miniBoardCache[boardId].cells;
            const cache = miniBoardCache[boardId];
            
            // ãƒ”ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—ãŒå¤‰ã‚ã£ãŸå ´åˆã®ã¿æ›´æ–°
            const pieceType = pieceData ? pieceData.type : null;
            if (cache.lastPieceType === pieceType) {
                return; // å¤‰æ›´ãªã—ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—
            }
            cache.lastPieceType = pieceType;
            
            // å…¨ã‚»ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    cells[row][col].className = 'mini-cell';
                }
            }
            
            // ãƒ”ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’é©ç”¨
            if (pieceData && typeof pieceData.type === 'number') {
                const pieceBlocks = getPieceBlocks(pieceData.type, 0); // ãƒŸãƒ‹ãƒœãƒ¼ãƒ‰ã¯å¸¸ã«0åº¦å›è»¢ã§è¡¨ç¤º
                
                if (pieceBlocks.length > 0) {
                    // ãƒ”ãƒ¼ã‚¹ã‚’ä¸­å¤®å¯„ã›ã™ã‚‹ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
                    let minX = Math.min(...pieceBlocks.map(b => b[0]));
                    let minY = Math.min(...pieceBlocks.map(b => b[1]));
                    let maxX = Math.max(...pieceBlocks.map(b => b[0]));
                    let maxY = Math.max(...pieceBlocks.map(b => b[1]));
                    
                    const pieceWidth = maxX - minX + 1;
                    const pieceHeight = maxY - minY + 1;
                    const offsetX = Math.floor((4 - pieceWidth) / 2) - minX;
                    const offsetY = Math.floor((4 - pieceHeight) / 2) - minY;
                    
                    for (const block of pieceBlocks) {
                        const row = block[1] + offsetY;
                        const col = block[0] + offsetX;
                        
                        if (row >= 0 && row < 4 && col >= 0 && col < 4) {
                            // PieceType (0-6) ã‚’ãã®ã¾ã¾ä½¿ç”¨
                            cells[row][col].classList.add(`type-${pieceData.type}`);
                        }
                    }
                }
            }
        }
        
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡
        function sendAction(action) {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                log('WebSocketãŒæ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const message = {
                action: action
            };
            
            socket.send(JSON.stringify(message));
            log(`é€ä¿¡: ${JSON.stringify(message)}`);
        }
        
        // ãƒ‡ãƒƒã‚­IDã‚’å–å¾—ã™ã‚‹é–¢æ•°
        async function getDeckId() {
            const authToken = document.getElementById('authToken').value;
            const userId = document.getElementById('userId').value;
            
            if (!authToken || !userId) {
                log('èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒå¿…è¦ã§ã™');
                return null;
            }
            
            // èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã«Bearerãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒä»˜ã„ã¦ã„ãªã„å ´åˆã¯è¿½åŠ 
            let authHeader = authToken;
            if (!authToken.startsWith('Bearer ')) {
                authHeader = `Bearer ${authToken}`;
            }
            
            try {
                const response = await fetch(`/api/protected/deck/${userId}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': authHeader
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`ãƒ‡ãƒƒã‚­å–å¾—ã‚¨ãƒ©ãƒ¼: ${response.status}`);
                }
                
                const data = await response.json();
                log(`ãƒ‡ãƒƒã‚­å–å¾—çµæœ: ${JSON.stringify(data)}`);
                
                if (data && data.deck && data.deck.id) {
                    return data.deck.id;
                } else {
                    log('ãƒ‡ãƒƒã‚­IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return null;
                }
            } catch (error) {
                log(`ãƒ‡ãƒƒã‚­å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                return null;
            }
        }
        
        // ãƒ«ãƒ¼ãƒ ä½œæˆ
        async function createRoom() {
            const userId = document.getElementById('userId').value;
            const authToken = document.getElementById('authToken').value;
            
            if (!userId) {
                alert('ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!authToken) {
                alert('èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            // ã¾ãšãƒ‡ãƒƒã‚­IDã‚’å–å¾—
            const deckId = await getDeckId();
            if (!deckId) {
                log('ãƒ‡ãƒƒã‚­IDã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                return;
            }
            
            // èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã«Bearerãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒä»˜ã„ã¦ã„ãªã„å ´åˆã¯è¿½åŠ 
            let authHeader = authToken;
            if (!authToken.startsWith('Bearer ')) {
                authHeader = `Bearer ${authToken}`;
            }
            
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': authHeader
            };
            
            fetch('/api/game/room', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    deck_id: deckId
                })
            })
            .then(response => response.json())
            .then(data => {
                log(`ãƒ«ãƒ¼ãƒ ä½œæˆçµæœ: ${JSON.stringify(data)}`);
                if (data.room_id) {
                    document.getElementById('roomId').value = data.room_id;
                }
            })
            .catch(error => {
                log(`ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
            });
        }
        
        // ãƒ«ãƒ¼ãƒ å‚åŠ 
        async function joinRoom() {
            const roomId = document.getElementById('roomId').value;
            const userId = document.getElementById('userId').value;
            const authToken = document.getElementById('authToken').value;
            
            if (!roomId || !userId) {
                alert('ãƒ«ãƒ¼ãƒ IDã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!authToken) {
                alert('èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            // ã¾ãšãƒ‡ãƒƒã‚­IDã‚’å–å¾—
            const deckId = await getDeckId();
            if (!deckId) {
                log('ãƒ‡ãƒƒã‚­IDã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                return;
            }
            
            // èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã«Bearerãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒä»˜ã„ã¦ã„ãªã„å ´åˆã¯è¿½åŠ 
            let authHeader = authToken;
            if (!authToken.startsWith('Bearer ')) {
                authHeader = `Bearer ${authToken}`;
            }
            
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': authHeader
            };
            
            fetch(`/api/game/room/${roomId}/join`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    deck_id: deckId
                })
            })
            .then(response => response.json())
            .then(data => {
                log(`ãƒ«ãƒ¼ãƒ å‚åŠ çµæœ: ${JSON.stringify(data)}`);
            })
            .catch(error => {
                log(`ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            });
        }
        
        // ã‚²ãƒ¼ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
        function handleGameMessage(data) {
            switch(data.type) {
                case 'game_state':
                    updateGameState(data);
                    break;
                case 'room_status':
                    updateRoomStatus(data);
                    break;
                case 'error':
                    log(`ã‚¨ãƒ©ãƒ¼: ${data.message}`);
                    break;
                default:
                    log(`æœªå¯¾å¿œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—: ${data.type}`);
            }
        }
        
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆé‡è¤‡æ›´æ–°ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
        let lastGameStateUpdate = 0;
        
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®æ›´æ–°ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ç‰ˆï¼‰
        function updateGameState(data) {
            // æ›´æ–°é »åº¦ã‚’åˆ¶é™ï¼ˆ60fpsåˆ¶é™ï¼‰
            const now = Date.now();
            if (now - lastGameStateUpdate < 16) { // ç´„60fps
                return;
            }
            lastGameStateUpdate = now;
            
            gameState = data;
            
            // ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®æ›´æ–°
            const gameStatus = data.status || 'ä¸æ˜';
            document.getElementById('gameStatus').textContent = gameStatus;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®çŠ¶æ…‹æ›´æ–°
            if (data.player1) {
                const player1Status = `å‚åŠ æ¸ˆã¿ (ID: ${data.player1.user_id || 'N/A'})`;
                document.getElementById('player1Status').textContent = player1Status;
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®ã‚²ãƒ¼ãƒ æƒ…å ±æ›´æ–°
                document.getElementById('player1Score').textContent = data.player1.score || 0;
                document.getElementById('player1Level').textContent = data.player1.level || 1;
                document.getElementById('player1Lines').textContent = data.player1.lines_cleared || 0;
                document.getElementById('player1GameOver').textContent = data.player1.is_game_over ? 'YES' : 'NO';
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®ãƒœãƒ¼ãƒ‰æç”»
                drawTetrisBoard('player1Board', data.player1.board, data.player1.current_piece);
                
                // Next/Holdãƒ”ãƒ¼ã‚¹æç”»
                drawMiniBoard('player1Next', data.player1.next_piece);
                drawMiniBoard('player1Hold', data.player1.held_piece);
            } else {
                document.getElementById('player1Status').textContent = 'æœªå‚åŠ ';
            }
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®çŠ¶æ…‹æ›´æ–°
            if (data.player2) {
                const player2Status = `å‚åŠ æ¸ˆã¿ (ID: ${data.player2.user_id || 'N/A'})`;
                document.getElementById('player2Status').textContent = player2Status;
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®ã‚²ãƒ¼ãƒ æƒ…å ±æ›´æ–°
                document.getElementById('player2Score').textContent = data.player2.score || 0;
                document.getElementById('player2Level').textContent = data.player2.level || 1;
                document.getElementById('player2Lines').textContent = data.player2.lines_cleared || 0;
                document.getElementById('player2GameOver').textContent = data.player2.is_game_over ? 'YES' : 'NO';
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®ãƒœãƒ¼ãƒ‰æç”»
                drawTetrisBoard('player2Board', data.player2.board, data.player2.current_piece);
                
                // Next/Holdãƒ”ãƒ¼ã‚¹æç”»
                drawMiniBoard('player2Next', data.player2.next_piece);
                drawMiniBoard('player2Hold', data.player2.held_piece);
            } else {
                document.getElementById('player2Status').textContent = 'æœªå‚åŠ ';
            }
            
            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ›´ã®ã¿ãƒ­ã‚°ã«è¨˜éŒ²
            log(`Game Status: ${gameStatus} | P1: ${data.player1 ? 'OK' : 'NO'} | P2: ${data.player2 ? 'OK' : 'NO'}`);
        }
        
        // ãƒ«ãƒ¼ãƒ çŠ¶æ…‹ã®æ›´æ–°
        function updateRoomStatus(data) {
            if (data.player1) {
                document.getElementById('player1Status').textContent = 'å‚åŠ æ¸ˆã¿';
            }
            if (data.player2) {
                document.getElementById('player2Status').textContent = 'å‚åŠ æ¸ˆã¿';
            }
        }
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
        document.addEventListener('keydown', function(event) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    sendAction('move_left');
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    sendAction('move_right');
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    sendAction('soft_drop');
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    sendAction('hard_drop');
                    break;
                case ' ':
                    event.preventDefault();
                    sendAction('rotate');
                    break;
                case 'c':
                case 'C':
                    event.preventDefault();
                    sendAction('hold');
                    break;
            }
        });
        
        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            log('ğŸ® GITRIS WebSocket Test Client ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ');
            
            // ãƒœãƒ¼ãƒ‰ã‚’é…å»¶åˆæœŸåŒ–ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ï¼‰
            setTimeout(() => {
                drawTetrisBoard('player1Board', []);
                drawTetrisBoard('player2Board', []);
                
                // ãƒŸãƒ‹ãƒœãƒ¼ãƒ‰ã‚‚åˆæœŸåŒ–
                drawMiniBoard('player1Next', null);
                drawMiniBoard('player1Hold', null);
                drawMiniBoard('player2Next', null);
                drawMiniBoard('player2Hold', null);
            }, 100);
            
            updateConnectionStatus('disconnected');
        });
    </script>
</body>
</html> 